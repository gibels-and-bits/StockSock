package com.yum.stocksock.stockList.mvi

import com.yum.stocksock.mvi.Action
import com.yum.stocksock.mvi.OneTimeEventEmitter
import com.yum.stocksock.mvi.Store
import com.yum.stocksock.stockList.mvi.event.FilterTypeChanged
import com.yum.stocksock.stockList.mvi.event.SearchTextEntered
import com.yum.stocksock.stockList.mvi.event.StockItemClick
import com.yum.stocksock.stockList.mvi.event.StockListEvent
import com.yum.stocksock.stockList.mvi.event.StockListScreenLoad
import com.yum.stocksock.stockList.mvi.usecase.filterStockList
import com.yum.stocksock.stockList.mvi.usecase.loadDetails
import com.yum.stocksock.stockList.mvi.usecase.loadScreen
import io.reactivex.Observable

class StockListStore() : Store<StockListEvent, StockListViewState>() {

    /**
     * Take any incoming Event from the user and map it into an Action via UseCase.
     *
     * We have an incoming stream of a sealed class.  UseCases depend on specific concrete
     * type extensions so we use ofType to filter the Observable and act accordingly.  All
     * of the resulting Action streams are merged.
     *
     * Interestingly, without publishing here with the provided selector, downstream there would
     * be a downstream subscription created for each ofType. We only want a single subscription
     * so publish does the trick.
     */
    override fun Observable<StockListEvent>.eventToActions(eventEmitter: OneTimeEventEmitter):
        Observable<out Action<StockListViewState>> {
        return publish { o ->
            Observable.merge( // The actions are generated by useCases
                o.ofType(SearchTextEntered::class.java).filterStockList(),
                o.ofType(FilterTypeChanged::class.java).filterStockList(),
                o.ofType(StockListScreenLoad::class.java).loadScreen(),
                o.ofType(StockItemClick::class.java).loadDetails(eventEmitter)
            )
        }
    }

    override fun makeDefaultViewState() = StockListViewState()
}